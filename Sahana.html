<!DOCTYPE HTML>
<!--
	Strongly Typed by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Sahana portfolio</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
<style>
    body {
        font-family: Arial, sans-serif; /* Ensure consistent font */
    }
</style>
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="no-sidebar is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<section id="header">
					<div class="container">

						<!-- Logo -->
							<h1 id="logo"><a href="index.html">Design and Analysis of<br><br>Algorithms</a></h1>
							

						<!-- Nav -->
							<nav id="nav">
								<ul>
									<li><a class="icon solid fa-home" href="index.html"><span>Introduction</span></a></li>
								
									<li><a class="icon solid fa-sitemap" href="Sahana.html"><span>Sahana</span></a></li>
									<li><a class="icon solid fa-sitemap" href="Srushti.html"><span>Srushti</span></a></li>
									<li><a class="icon solid fa-sitemap" href="Srujana.html"><span>Srujana</span></a></li>
									<li><a class="icon solid fa-sitemap" href="Sinchana.html"><span>Sinchana</span></a></li>
								</ul>
							</nav>

					</div>
				</section>

			<!-- Main -->
				<section id="main">
					<div class="container">
						<div id="content">

							<!-- Post -->
								<article class="box post">
									<header>
										<h2> <strong>Portfolio</strong> <br />
										</h2>
                                     

<p>Hello, I‚Äôm <strong>Sahana V Agadi</strong><br>
I am passionate about technology and problem-solving. Here‚Äôs a glimpse of my work:</p>

<p><strong>üõ† Projects</strong><br>
- <strong>RescueNet:</strong> Emergency Response System<br>
Designed emergency management systems for ensuring rapid responses during disasters.<br>
- <strong>Mechanical Nut Counter:</strong><br>
Designed a machine that counts the number of nuts using a sensor and displays the total number.</p>

<p><strong>üöÄ Skills</strong><br>
C, C++, Python, SQL<br>
Data Structures and Algorithms</p>

<p><strong>üåê Find Me Online</strong><br>
<strong>GitHub:</strong> <a href="https://github.com/Sahana2809">https://github.com/Sahana2809</a><br>
<strong>Email:</strong> sahanavagadi@gmail.com</p>

<p><strong>Project Report: </strong><button onclick="window.location.href = 'https://drive.google.com/file/d/1khahrS8uC_EJ7Ko4gbed9NpiNFb7GVtd/view?usp=drive_link';">Click here</button></p>
<p><strong>Course Name:</strong> Design And Analysis of Algorithms<br>
<strong>Course Code:</strong> 24ECSC205<br>
<strong>Name:</strong> Sahana V Agadi<br>
<strong>SRN:</strong> 01FE23BCS091<br>
<strong>Course Instructor:</strong> Mallikarjun Akki<br>
<strong>University:</strong> KLE Technological University</p>
									</header>
									
                                    <header>
										<h3>Course Reflection<br></h3>
									</header>

									
									<p>
									<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Course Learning Reflections</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            line-height: 1.6;
            margin: 20px;
        }
        h1, h2, h3 {
            color: #333;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>

<h1>Course Learning Reflections</h1>

<p><strong>1. Kinds of Problems We See in Nature: Iteration, Recursion, Backtracking</strong></p>
<p>Nature provides numerous examples that parallel the concepts of iteration, recursion, and backtracking in computational terms:</p>
<ul>
    <li><strong>Iteration:</strong> The recurring cycle of seasons is a clear representation of iteration. Each season follows the previous one in a predictable manner, similar to how loops in programming repeat a set of instructions until a condition is met.</li>
    <li><strong>Recursion:</strong> The growth pattern of cabbage leaves, where each layer forms upon the previous one, embodies recursion. This process builds upon itself, akin to a function calling itself to solve smaller instances of a problem.</li>
    <li><strong>Backtracking:</strong> Ants foraging for food illustrate backtracking. They traverse paths in search of resources and, upon encountering obstacles or dead ends, retrace their steps to explore alternative routes. This mirrors the backtracking technique in algorithms, where paths are explored and retracted when they lead to dead ends.</li>
</ul>
<p>These examples showcase how fundamental algorithmic principles are intricately mirrored in natural processes, emphasizing the profound connection between computational logic and the patterns observed in the natural world.</p>

<p><strong>2. Space and Time Efficiency: Importance and Classes of Problems</strong></p>
<p><strong>Space Efficiency:</strong> Refers to how well an algorithm uses memory during execution. Space complexity measures the amount of memory required in relation to input size. This is critical in systems with limited resources, such as embedded systems or when processing large datasets.</p>
<p><strong>Time Efficiency:</strong> Measures how fast an algorithm performs its task based on the input size, often quantified through time complexity. It is essential for large datasets or real-time applications.</p>

<p><strong>Classes of Problems and Orders of Growth</strong></p>
<p>The orders of growth of an algorithm describe how time or space requirements grow as the input size increases:</p>
<ul>
    <li>O(1): Constant time (e.g., accessing an array element).</li>
    <li>O(log n): Logarithmic time (e.g., binary search).</li>
    <li>O(n): Linear time (e.g., iterating through an array).</li>
    <li>O(n log n): Log-linear time (e.g., merge sort).</li>
    <li>O(n¬≤): Quadratic time (e.g., bubble sort).</li>
    <li>O(2‚Åø): Exponential time (e.g., solving the traveling salesman problem).</li>
</ul>
<p>Understanding these complexities is crucial for assessing an algorithm's efficiency, enabling programmers to determine its suitability for specific applications.</p>

<p><strong>3. Takeaways from Different Design Principles</strong></p>
<ul>
    <li>Studying different algorithms has helped me grasp their key principles and applications more clearly. Key takeaways include:</li>
    <li><strong>Decomposition:</strong> Breaking complex problems into smaller, manageable sub-problems simplifies analysis and solution development.</li>
    <li><strong>Pattern Recognition:</strong> Identifying recurring structures or behaviors in data or algorithms allows leveraging reusable solutions.</li>
    <li><strong>Abstraction:</strong> Focusing on essential details while ignoring unnecessary complexities simplifies the problem-solving process.</li>
    <li><strong>Lazy Propagation/Evaluation:</strong> Delaying computation until necessary optimizes performance, commonly used in segment trees and other optimization algorithms.</li>
    <li><strong>Sliding Window:</strong> This technique efficiently solves problems involving subarrays or substrings, optimizing space and time complexity .</li>
    <li><strong>Pruning:</strong> Eliminating unnecessary computations or paths in a search space optimizes performance, as seen in branch-and-bound algorithms.</li>
    <li><strong>Memoization and Pre-computing:</strong> Storing intermediate results during runtime avoids redundant computations, while pre-computing results for static data improves runtime efficiency.</li>
    <li><strong>Level Order Traversal:</strong> Exploring tree structures level by level aids in understanding hierarchical relationships and processing nodes systematically.</li>
    <li><strong>Hierarchical Data:</strong> Organizing data in parent-child relationships facilitates efficient data management and retrieval.</li>
    <li><strong>Edge Relaxation:</strong> Updating the shortest known distances in graphs is crucial for algorithms like Dijkstra's and Bellman-Ford.</li>
    <li><strong>Balancing and Rotations:</strong> Maintaining balance in tree structures ensures optimal performance for search, insert, and delete operations.</li>
    <li><strong>Kleene Closure:</strong> Finding all possible connections or paths in a set of states or nodes is essential in automata theory and graph traversal.</li>
    <li><strong>Parental Dominance:</strong> Understanding that parent nodes dominate child nodes helps in optimizing tree-based algorithms.</li>
    <li><strong>Prefix and Suffix:</strong> Utilizing precomputed arrays for prefix and suffix sums can significantly enhance search and query efficiency.</li>
    <li><strong>Partitioning:</strong> Dividing data into manageable segments improves processing and management, especially in sorting and searching algorithms.</li>
    <li><strong>Bit Manipulations:</strong> Optimizing operations using bitwise techniques can lead to more efficient algorithms, particularly in low-level programming and performance-critical applications.</li>
</ul>

<p><strong>4. Hierarchical Data and Tree Data Structures</strong></p>
<p><strong>Hierarchical Data:</strong> Data organized in a tree-like structure where each element (node) is connected to one or more sub-elements (child nodes) through parent-child relationships. It allows efficient representation, traversal, and management of complex relationships.</p>
<p>Hierarchical data can be effectively represented and navigated using various tree data structures. These structures optimize searching, balancing, and organization of data, with each being an improvement over the previous one:</p>
<ul>
    <li><strong>Binary Tree:</strong> Each node has at most two children.</li>
    <li><strong>Binary Search Tree (BST):</strong> A binary tree where the left and right subtrees are ordered for efficient searching, insertion, and deletion.</li>
    <li><strong>AVL Tree:</strong> A self-balancing BST with a height difference constraint between subtrees, ensuring O(log n) time complexity for operations.</li>
    <li><strong>Red-Black Tree:</strong> A self-balancing BST with a more relaxed balancing requirement, also ensuring O(log n) time complexity.</li>
    <li><strong>2-3 Tree:</strong> A balanced tree that maintains sorted order and ensures all leaf nodes are at the same level.</li>
    <li><strong>Heap:</strong> A complete binary tree that maintains a special order, making it suitable for priority queues.</li>
    <li><strong>Trie:</strong> A tree-like structure used for storing strings, optimizing operations like autocomplete.</li>
</ul>
<p>These structures optimize search, insertion, and deletion operations, making them essential for efficient data management.</p>

<p><strong>5. Need for Array Query Algorithms and Their Implications</strong></p>
<p>Efficient array query algorithms are crucial for managing large datasets with frequent updates. They enable quick responses to various queries, such as sum, minimum, or maximum, without the need for recalculating values each time. These algorithms optimize query processing, especially for large datasets, by significantly reducing time complexity compared to direct computation for each query. Their importance is underscored in applications where both static and dynamic arrays are involved, and multiple queries need to be handled efficiently.</p>

<p><strong>Sparse Table</strong></p>
<ul>
    <li><strong>Principle:</strong> Precomputes and stores results to allow for constant-time range queries after an initial preprocessing phase.</li>
    <li><strong>Application:</strong> Best suited for static data with frequent range queries, such as finding minimum or maximum values over a range.</li>
    <li><strong>Implication:</strong> Offers fast query times post-preprocessing, but requires significant upfront preprocessing time, making it less suitable for dynamic datasets.</li>
</ul>

<p><strong>Fenwick Tree (Binary Indexed Tree)</strong></p>
<ul>
    <li><strong>Principle:</strong></ li>Utilizes a clever bitwise approach to efficiently handle prefix sum queries and point updates in O(log n) time.</li>
    <li><strong>Application:</strong> Commonly used in problems involving cumulative sums or frequency counts, such as calculating the sum of elements in a range.</li>
    <li><strong>Implication:</strong> Provides efficient updates and queries, but requires additional space for storage, which can be a consideration in memory-constrained environments.</li>
</ul>

<p><strong>Segment Tree</strong></p>
<ul>
    <li><strong>Principle:</strong> Supports efficient range queries and point updates in O(log n) time, allowing for dynamic updates to the dataset.</li>
    <li><strong>Application:</strong> Suitable for dynamic datasets requiring range queries, such as sum, minimum, or maximum queries, making it versatile for various applications.</li>
    <li><strong>Implication:</strong> Highly efficient for dynamic data, though it requires more space and time for construction compared to other data structures, which can impact performance in scenarios with limited resources.</li>
</ul>

<p><strong>Practical Applications</strong></p>
<p>These array query algorithms have significant practical applications. For instance, they enable price filters on shopping sites like Amazon, allowing customers to search within specific price ranges efficiently. Similarly, financial platforms utilize range queries to analyze stock trends over chosen periods, demonstrating the importance of these algorithms in modern data-driven applications. By balancing speed and simplicity, these structures are vital for enhancing user experience and operational efficiency in various domains.</p>

<p><strong>6. Differentiating Between Trees and Graphs</strong></p>
<table>
    <tr>
        <th>Aspect</th>
        <th>Tree</th>
        <th>Graph</th>
    </tr>
    <tr>
        <td>Definition</td>
        <td>Hierarchical structure with one root node, no cycles.</td>
        <td>Collection of nodes connected by edges; may have cycles.</td>
    </tr>
    <tr>
        <td>Structure</td>
        <td>Connected acyclic graph.</td>
        <td>Can be connected or disconnected, cyclic or acyclic.</td>
    </tr>
    <tr>
        <td>Root</td>
        <td>Has one root node.</td>
        <td>May not have a root node.</td>
    </tr>
    <tr>
        <td>Edges</td>
        <td>n - 1 edges for n nodes.</td>
        <td>Any number of edges.</td>
    </tr>
    <tr>
        <td>Traversal</td>
        <td>Pre-order, In-order, Post-order, Level-order.</td>
        <td>DFS, BFS.</td>
    </tr>
    <tr>
        <td>Applications</td>
        <td>File systems, decision trees, routing algorithms.</td>
        <td>Social networks, shortest path algorithms, web crawling.</td>
    </tr>
</table>

<p><strong>Applications of Trees and Graphs</strong></p>
<table>
    <tr>
        <th>Application Area</th>
        <th>Trees</th>
        <th>Graphs</th>
    </tr>
    <tr>
        <td>File Systems</td>
        <td>Organize files hierarchically.</td>
        <td>-</td>
    </tr>
    <tr>
        <td>Database Indexing</td>
        <td>B-trees, AVL trees.</td>
        <td>-</td>
    </tr>
    <tr>
        <td>Decision Trees</td>
        <td>Used in machine learning models.</td>
        <td>-</td>
    </tr>
    <tr>
        <td>Social Networks</td>
        <td>-</td>
        <td>Represent user relationships.</td>
    </tr>
    <tr>
        <td>Shortest Path</td>
        <td>-</td>
        <td>Used in navigation systems (e.g., Dijkstra, A*).</td>
    </tr>
    <tr>
        <td>Web Crawling</td>
        <td>-</td>
        <td>Indexing web pages using graph traversal algorithms.</td>
    </tr>
</table>

<p><strong>7. Sorting and Searching Algorithms</strong></p>
<p><strong>Sorting Algorithms:</strong> Sorting algorithms arrange data in a specific order (ascending or descending). Key algorithms include:</p>
<ul>
    <li><strong>Bubble Sort:</strong> Repeatedly compares and swaps adjacent elements.</li ```html
    <li><strong>Insertion Sort:</strong> Inserts elements into the sorted portion one by one.</li>
    <li><strong>Selection Sort:</strong> Finds the smallest/largest element and places it in the sorted section.</li>
    <li><strong>Merge Sort:</strong> Recursively splits and merges sorted halves.</li>
    <li><strong>Quick Sort:</strong> Partitions the array around a pivot for sorting.</li>
    <li><strong>Heap Sort:</strong> Utilizes a heap data structure to sort elements.</li>
</ul>

<p><strong>Searching Algorithms:</strong> Searching algorithms help find specific items within data structures. Key algorithms include:</p>
<ul>
    <li><strong>Linear Search:</strong> Checks each item one by one, making it simple but inefficient for large datasets, with a time complexity of O(n).</li>
    <li><strong>Binary Search:</strong> Efficiently finds an item in a sorted array by repeatedly dividing the search interval in half, achieving a time complexity of O(log n).</li>
    <li><strong>Depth-First Search (DFS):</strong> Explores as far as possible along each branch before backtracking, commonly used in graph traversal and tree structures.</li>
    <li><strong>Breadth-First Search (BFS):</strong> Explores all neighbors at the present depth prior to moving on to nodes at the next depth level, useful for finding the shortest path in unweighted graphs.</li>
    <li><strong>Brute Force String Search:</strong> A straightforward method that checks every possible position in the text for a match with the pattern. While simple, it can be inefficient with a time complexity of O(n*m), where n is the length of the text and m is the length of the pattern.</li>
    <li><strong>Boyer-Moore Algorithm:</strong> An efficient string searching algorithm that skips sections of the text based on mismatches, using precomputed information about the pattern. It can achieve sub-linear time complexity in the best cases, making it faster than brute force for many practical applications.</li>
    <li><strong>KMP Algorithm (Knuth-Morris-Pratt):</strong> This algorithm preprocesses the pattern to create a partial match table, allowing the search to skip unnecessary comparisons in the text. It operates in O(n + m) time, making it efficient for searching patterns in large texts.</li>
    <li><strong>Rabin-Karp Algorithm:</strong> Utilizes hashing to find any one of a set of pattern strings in a text. It computes a hash value for the pattern and compares it to hash values of substrings in the text, allowing for efficient searching with an average time complexity of O(n + m) but can degrade to O(n*m) in the worst case due to hash collisions.</li>
</ul>

<p>These algorithms are widely used in real-world applications, such as database management, e-commerce platforms, and data analysis, where efficient searching is critical for performance and user experience.</p>

<p><strong>8. Importance of Graph Algorithms</strong></p>
<p>Graph algorithms are essential tools for solving real-world problems related to networks, resource optimization, and connectivity. They play a crucial role in various applications, particularly in the areas of spanning trees and shortest paths.</p>

<p><strong>Spanning Trees</strong></p>
<ul>
    <li><strong>Purpose:</strong> The primary goal of spanning trees is to minimize connectivity costs in networks. A spanning tree connects all vertices in a graph with the minimum number of edges and no cycles, ensuring efficient resource use.</li>
    <li><strong>Algorithms:</strong>
        <ul>
            <li><strong>Prim's Algorithm:</strong> This algorithm builds the Minimum Spanning Tree (MST) by iteratively selecting the smallest edge from a growing subset of the graph.</li>
            <li><strong>Kruskal's Algorithm:</strong> This approach constructs the MST by selecting the smallest edges across the entire graph while avoiding cycles.</li>
        </ul>
    </li>
    <li><strong>Applications:</strong> Spanning trees are widely used in network design (e.g., optimizing cable or fiber-optic layouts), circuit design, and efficient data routing.</li>
</ul>

<p><strong>Shortest Paths</strong></p>
<ul>
    <li><strong>Purpose:</strong> Shortest path algorithms aim to optimize routes for navigation and communication, finding the minimum distance or cost between two nodes in a graph.</li>
    <li><strong>Algorithms:</strong>
        <ul>
            <li><strong>Dijkstra's Algorithm:</strong> This algorithm finds the shortest path from a single source to all other nodes in a weighted graph, making it ideal for applications requiring real-time pathfinding.</li>
            <li><strong>Floyd-Warshall Algorithm:</strong> This algorithm computes shortest paths between all pairs of nodes in a graph, useful for comprehensive route analysis.</li>
        </ul>
    </li>
    <li><strong>Applications:</strong> Shortest path algorithms are critical in GPS navigation, internet routing protocols, logistics planning, and transportation systems, where finding the most efficient routes is essential.</li>
</ul>

<p><strong>Significance of Graph Algorithms:</strong></p>
<p>Graph algorithms, particularly spanning trees and shortest path algorithms, are vital for solving real-world problems across various domains:</p>
<ul>
    <li><strong>Network Design:</strong> They optimize layouts for cables and fiber optics, reducing infrastructure costs.</li>
    <li><strong>Transportation Systems:</strong> They help find the shortest routes for vehicles and deliveries, improving efficiency and reducing travel time.</li>
    <li><strong>Social Networks:</strong> They identify optimal connections between users, enhancing engagement and connectivity.</li>
    <li><strong>Resource Allocation:</strong> They minimize costs in distributing limited resources across networks, ensuring effective management.</li>
</ul>
<p>These algorithms enhance efficiency and cost-effectiveness in diverse applications, making them essential tools in modern problem-solving.</p>

<p><strong>9. Studied Algorithm Design Techniques</strong></p>
<p>Algorithm design techniques are essential for efficiently solving complex problems across various domains.</p>
<ol>
    <li><strong>Divide and Conquer:</strong> This technique breaks a problem into smaller sub-problems, solves them independently, and combines their results.
        <ul>
            <li>Examples: Merge Sort, Quick Sort, Binary Search.</li>
        </ul>
    </li>
    <li><strong>Dynamic Programming:</strong> This approach solves complex problems by breaking them into overlapping sub-problems and storing their solutions to avoid redundant computations.
        <ul>
            <li>Examples: Fibonacci Sequence, Longest Common Subsequence, Knapsack Problem.</li>
        </ul>
    </li>
    <li><strong>Greedy Method:</strong> Greedy algorithms make the locally optimal choice at each step, aiming for a globally optimal solution.
        <ul>
            <li>Examples: Kruskal's Algorithm, Prim's Algorithm, Dijkstra‚Äôs Algorithm for shortest paths.</li>
        </ul>
    </li>
    <li><strong>Backtracking:</strong> This technique explores all possible options to solve a problem by incrementally building a solution and abandoning paths that fail to satisfy conditions.
        <ul>
            <li>Examples: N-Queens Problem, Sudoku Solver, Graph Coloring.</li>
        </ul>
    </li>
    <li><strong>Brute Force:</strong> Brute force systematically tries all possible solutions to find the correct one.
        <ul>
            <li>Examples: String Matching (Na√Øve Algorithm), Traveling Salesman Problem (Exhaustive Search).</li>
        </ul>
    </li>
    <li><strong>Recursion:</strong> Recursion solves a problem by having a function call itself with a smaller input until a base case is reached.
        <ul>
            <li>Examples: Factorial Calculation, Tower of Hanoi, Depth-First Search.</li>
        </ul>
    </li>
    <li><strong>Randomized Algorithms:</strong> These algorithms use random numbers to make decisions, ensuring efficiency or simplicity in problem-solving.
        <ul>
            <li>Examples: Quick Sort (Random Pivot), Monte Carlo Algorithm, Randomized Primality Testing.</li>
        </ul>
    </li>
    <li><strong>String Search Algorithms:</strong> Specialized algorithms designed to quickly search for patterns in text, enhancing tasks like searching for a word in a document.
        <ul>
            <li>Examples: Boyer-Moore, Knuth-Morris-Pratt, Rabin-Karp.</li>
        </ul>
    </li>
    <li><strong>Shortest Path Algorithms:</strong> Focused on finding the fastest route or shortest path in a network, essential for navigation and efficient connectivity.
        <ul>
            <li>Examples: Dijkstra's Algorithm, Floyd-Warshall Algorithm, Prim's Algorithm.</li>
        </ul>
    </li>
</ol>

<p><strong>Significance of Algorithm Design Techniques:</strong></p>
<ul>
    <li><strong>Efficiency:</strong> Reduces time and space complexity, enabling the handling of large datasets effectively.</li>
    <li><strong>Scalability:</strong> Adapts to problems of varying sizes and complexities.</li>
    <li><strong>Optimization:</strong> Ensures the best or near-best solutions in constrained environments.</li>
    <li><strong>Broad Applicability:</strong> Used across various fields, including artificial intelligence, networking, and finance.</li>
    <li><strong>Problem-Solving:</strong> Enhances the ability to tackle diverse challenges more effectively and efficiently.</li>
</ul>

</body>
</html>

									</p>
								</article>

						</div>
					</div>
				</section>

			

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>

			<!-- Footer -->
			

		

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
