<!DOCTYPE HTML>
<!--
	Strongly Typed by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Srushti B Bammanawadi</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="no-sidebar is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<section id="header">
					<div class="container">

						<!-- Logo -->
							<h1 id="logo"><a href="index.html">Design and Analysis of
 							<br><br><br>Algorithms</a></h1>
							

						<!-- Nav -->
							<nav id="nav">
								<ul>
									<li><a class="icon solid fa-home" href="index.html"><span>Introduction</span></a></li>
									<li>
										
										<ul>
											<li><a href="#">Lorem ipsum dolor</a></li>
											<li><a href="#">Magna phasellus</a></li>
											<li><a href="#">Etiam dolore nisl</a></li>
											<li>
												<a href="#">Phasellus consequat</a>
												<ul>
													<li><a href="#">Magna phasellus</a></li>
													<li><a href="#">Etiam dolore nisl</a></li>
													<li><a href="#">Phasellus consequat</a></li>
												</ul>
											</li>
											<li><a href="#">Veroeros feugiat</a></li>
										</ul>
									</li>
									<li><a class="icon solid fa-cog" href="Sahana.html"><span>Sahana</span></a></li>
									<li><a class="icon solid fa-retweet" href="Srushti.html"><span>Srushti</span></a></li>
									<li><a class="icon solid fa-retweet" href="Srujana.html"><span>Srujana</span></a></li>
									<li><a class="icon solid fa-sitemap" href="Sinchana.html"><span>Sinchana</span></a></li>
								</ul>
							</nav>

					</div>
				</section>

			<!-- Main -->
				<section id="main">
					<div class="container">
						<div id="content">

							<!-- Post -->
								<article class="box post">
									<header>
										<h2> <strong>COURSE REFLECTION</strong> <br />
										By Srujana K Pagi</h2>
									</header>
									
									<h3>And yeah, that's basically it</h3>
									<p>
										
										<p><strong>What are the kinds of problems we see in nature?</strong></p>  
<p>In nature, we see iteration in things like the changing seasons or animals following their migration routes year after year. Recursion shows up in patterns like the way trees branch out, shells spiral, or cabbage grows in layers. Then there’s backtracking, like when ants explore their surroundings and find their way back home, or when predators adjust their approach while hunting. These processes are like nature’s way of solving problems, much like how we use these concepts in computing.</p>  

<p><strong>What is space and time efficiency? Why are they important?</strong></p>  
<p><strong>Space Efficiency:</strong> Refers to minimizing memory usage.</p>  
<p><strong>Time Efficiency:</strong> Focuses on reducing execution time. Efficient algorithms are crucial for handling large inputs, saving resources, and improving performance.</p>  

<p><strong>Classes of Problems:</strong></p>  
<ul>  
  <li><strong>Constant (O(1)):</strong> Fixed time (e.g., accessing an array element).</li>  
  <li><strong>Logarithmic (O(log n)):</strong> Scales with the logarithm of input (e.g., binary search).</li>  
  <li><strong>Linear (O(n)):</strong> Scales proportionally with input (e.g., array traversal).</li>  
  <li><strong>Linearithmic (O(n log n)):</strong> Common in sorting (e.g., merge sort).</li>  
  <li><strong>Quadratic (O(n^2)):</strong> Nested loops (e.g., bubble sort).</li>  
  <li><strong>Exponential (O(2^n)):</strong> Grows rapidly (e.g., brute-force TSP).</li>  
  <li><strong>Factorial (O(n!)):</strong> Extremely slow (e.g., generating permutations).</li>  
</ul>  

<p><strong>Orders of Growth:</strong> Growth rates help evaluate best, worst, and average-case performance, guiding algorithm selection for better efficiency in real-world applications.</p>  

<p><strong>Takeaways from different design principles:</strong></p>  
<p>As I delved into different algorithms, the key concepts started to become clearer. Understanding how AVL trees and Red-Black trees keep their balance underscored the importance of structured data and efficient operations. Comparing the daring and careful approaches of DFS and BFS in graph traversal illustrated how varying strategies can effectively solve problems. Lastly, learning how sorting algorithms function—whether by dividing and merging or swapping elements—helped me grasp their underlying principles. Overall, these insights have provided a solid understanding of algorithmic foundations.</p>  

<p><strong>Hierarchical data and tree data structures:</strong></p>  
<p>Tree data structures are great for organizing hierarchical data and solving different types of problems. Binary Search Trees (BSTs) help with faster searches by keeping nodes in order, but they can get unbalanced over time. The 2-3 tree solves this by automatically balancing itself and keeping all leaf nodes at the same level, though it can still become a bit skewed. The AVL tree improves on this by using a balancing factor and rotations to keep things more evenly spread out. To make balancing even more efficient, the Red-Black tree was introduced, requiring fewer rotations. Heaps are complete binary trees that maintain a special order, making them perfect for priority queues where you need quick access to the highest or lowest value. Lastly, Tries are trees designed to store and search strings quickly, commonly used in things like autocomplete and prefix searching.</p>  

<p><strong>Array query algorithms and their implications:</strong></p>  
<p>Array query algorithms are essential for quickly searching, updating, and processing data in arrays, especially when dealing with large amounts of data. They’re used in applications like databases, search engines, and real-time systems. Common tasks include finding specific elements, performing range queries (like summing values or finding the minimum/maximum), and updating data. These algorithms often use techniques like preprocessing (e.g., creating prefix sums), divide and conquer (like binary search), and specialized structures (like Fenwick trees) to speed up operations. By making these tasks more efficient, array query algorithms help improve performance in various applications.</p>  

<p><strong>Tree and Graphs: Differences and Traversals</strong></p>  
<p>Trees are like family trees or organization charts—they have a clear starting point (the root) and show a simple, one-way relationship between elements, without any loops. Graphs, on the other hand, are more flexible and complex. They can have cycles and multiple connections between nodes, making them great for modeling things like social networks or road maps.</p>  

<p><strong>Tree Traversals:</strong></p>  
<ul>  
  <li>Pre-order</li>  
  <li>In-order</li>  
  <li>Post-order</li>  
</ul>  
<p><strong>Graph Traversals:</strong></p>  
<ul>  
  <li>DFS (Depth-First Search)</li>  
  <li>BFS (Breadth-First Search)</li>  
</ul>  

<p><strong>Applications:</strong></p>  
<p>Trees are used in hierarchical data representation (e.g., file systems), searching (e.g., BSTs), and priority queues (e.g., heaps). Graphs are used in social networks, routing systems, and computer networks.</p>  

<p><strong>Sorting and Searching Algorithms:</strong></p>  
<p>Sorting algorithms, like Quick Sort and Merge Sort, help organize data quickly—think of sorting a list of names or arranging search results. Searching algorithms, like Binary Search and Linear Search, help find specific items—Binary Search is faster for sorted data, while Linear Search checks each item one by one. These algorithms are used in everyday tasks like online shopping, managing inventories, or analyzing data, making everything run faster and more smoothly.</p>  

<p><strong>Graph Algorithms, Spanning Trees, and Shortest Paths:</strong></p>  
<p>Graph algorithms are essential for finding the best connections in networks. Spanning tree algorithms, like Kruskal's and Prim's, help link all points in a network without any loops, minimizing costs—think of building the least expensive road system between cities. Shortest path algorithms, such as Dijkstra's and Bellman-Ford, help find the fastest route between two points, which is key in GPS navigation or internet routing. These algorithms make networks and connections more efficient in real-world applications.</p>  

<p><strong>Algorithm Design Techniques:</strong></p>  
<ul>  
  <li><strong>Backtracking:</strong> Trying different paths to solve a problem and giving up on those that don’t work (e.g., N-Queens problem).</li>  
  <li><strong>Sorting Algorithms:</strong></li>  
  <ul>  
    <li><strong>Divide and Conquer:</strong> Algorithms like Quick Sort and Merge Sort break down a problem into smaller parts, solve them, and then combine the results.</li>  
    <li><strong>Comparison-Based:</strong> Methods like Selection Sort, Insertion Sort, and Bubble Sort work by comparing elements and organizing them step by step.</li>  
  </ul>  
  <li><strong>Brute Force:</strong> Simply tries all possible solutions one by one, which works but can be slow for larger problems.</li>  
  <li><strong>String Search Algorithms:</strong> Boyer-Moore, Knuth-Morris-Pratt, and Rabin-Karp are designed to quickly search for patterns in text.</li>  
  <li><strong>Shortest Path Algorithms:</strong> Dijkstra’s, Floyd’s, Warshall’s, and Prim’s are used for finding the fastest route or shortest path in a network.</li>  
</ul>  
</p>
								</article>

						</div>
					</div>
				</section>

			

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>