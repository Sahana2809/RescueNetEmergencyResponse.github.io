<!DOCTYPE HTML>
<!--
	Strongly Typed by HTML5 UP
	html5up.net | @ajlkn
	Free for personal and commercial use under the CCA 3.0 license (html5up.net/license)
-->
<html>
	<head>
		<title>Srushti B Bammanawadi</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
	</head>
	<body class="no-sidebar is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<section id="header">
					<div class="container">

						<!-- Logo -->
							<h1 id="logo"><a href="index.html">Design and Analysis of
 							<br><br><br>Algorithms</a></h1>
							

						<!-- Nav -->
							<nav id="nav">
								<ul>
									<li><a class="icon solid fa-home" href="index.html"><span>Introduction</span></a></li>
									
									<li><a class="icon solid fa-cog" href="Sahana.html"><span>Sahana</span></a></li>
									<li><a class="icon solid fa-retweet" href="Srushti.html"><span>Srushti</span></a></li>
									<li><a class="icon solid fa-retweet" href="Srujana.html"><span>Srujana</span></a></li>
									<li><a class="icon solid fa-sitemap" href="Sinchana.html"><span>Sinchana</span></a></li>
								</ul>
							</nav>

					</div>
				</section>

			<!-- Main -->
				<section id="main">
					<div class="container">
						<div id="content">

							<!-- Post -->
								<article class="box post">
									<header>
										<h2> <strong>Portfolio</strong> <br />
										</h2>
                                        

<p>Hello, I‚Äôm <strong>Srushti Bammanawadi</strong><br>
I am passionate about technology and problem-solving. Here‚Äôs a glimpse of my work:</p>

<p><strong>üõ† Projects</strong><br>
<strong>RescueNet:</strong> Emergency Response System<br>
Designed emergency management systems for ensuring rapid responses during disasters.<br>
<strong>Mechanical Counter:</strong><br>
Designed a machine that counts the votes given to a candidate and displays the winning candidate. The machine is aesthetically pleasing, easy to use, and lightweight for portability. Additionally, it features a user-friendly interface with clear instructions for voters.</p>

<p><strong>üöÄ Skills</strong><br>
C, C++, Python, SQL<br>
Data Structures and Algorithms</p>

<p><strong>üåê Find Me Online</strong><br>
<strong>GitHub:</strong> <a href="https://github.com/SrushtiBB">https://github.com/SrushtiBB</a><br>
<strong>Email:</strong> srushtibb31@gmail.com</p>

<p><strong>Project Report: </strong><button onclick="window.location.href = 'https://drive.google.com/file/d/1doF9STiDpNSkUc3ox2KS4zq3rhmUuIuV/view?usp=drive_link';">HOME</button></p>
<p><strong>Course Name:</strong> Design And Analysis of Algorithms<br>
<strong>Course Code:</strong> 24ECSC205<br>
<strong>Name:</strong> Srushti Bammanawadi<br>
<strong>SRN:</strong> 01FE23BCS098<br>
<strong>Course Instructor:</strong> Mallikarjun Akki<br>
<strong>University:</strong> KLE Technological University</p>
									</header>
									
									<header>
										<h3>Course Reflection<br></h3>
									</header>

									<p>
									
										
										<p><strong>1. Problems in Nature: Iteration, Recursion, Backtracking</strong></p>
										
										<p><strong>Iteration</strong><br>Definition: Iteration is a process where a set of instructions is repeated until a specific condition is met. This is commonly done using loops in programming.<br>Example: Imagine you want to count how many apples you have in a basket. You can go through each apple one by one, counting them until you reach the end of the basket. This is similar to how iteration works in programming, where you repeat an action (like counting) until you finish the task.</p>
										
										<p><strong>Recursion</strong><br>Definition: Recursion is a technique where a function calls itself to solve smaller instances of the same problem. Each call should bring the problem closer to a base case, which is a condition that stops the recursion.<br>Example: Think of a situation where you need to find the total number of layers in a nested set of boxes. You can open the outer box, count it, and then check if there‚Äôs another box inside. If there is, you repeat the process for the inner box until you reach a box that has no more boxes inside. This is similar to how recursion works, where each step involves solving a smaller part of the problem.</p>
										
										<p><strong>Backtracking</strong><br>Definition: Backtracking is an algorithmic approach for solving problems incrementally. It involves trying out different possibilities and abandoning those that do not lead to a valid solution.<br>Example: Consider a maze where you need to find a way out. You start at the entrance and try to move in one direction. If you hit a wall or a dead end, you go back to the last decision point and try a different path. This process of exploring paths and backtracking when necessary is a classic example of backtracking.</p>
										<br>
					
										<p><strong>2.Space and Time Efficiency</strong>
										
										<strong>Definitions</strong><br>Time Efficiency: Time efficiency refers to the amount of time an algorithm takes to complete as a function of the length of the input. It is often expressed using Big O notation, which classifies algorithms based on their worst-case or average-case performance. The goal is to minimize the time taken to execute an algorithm, especially as the size of the input grows.<br>Space Efficiency: Space efficiency measures the amount of memory an algorithm uses relative to the input size. Like time efficiency, it is also expressed in Big O notation. The aim is to use as little memory as possible while still achieving the desired functionality.
										
										
										<ul>
											<p><strong>Importance</strong></p>
											<strong>Why Time Efficiency Matters:</strong>
										  <li><strong>Performance:</strong> In applications where speed is critical (like real-time systems, gaming, or high-frequency trading), time efficiency can significantly impact user experience and system performance.</li>
										  <li><strong>Scalability:</strong> As data sizes grow, algorithms that are not time-efficient may become impractical. For example, an algorithm that takes O(n¬≤) time may work fine for small datasets but can become unmanageable for larger datasets.</li>
										</ul>
										</p>
										
										<ul>
											<strong>Why Space Efficiency Matters:</strong>
										  <li><strong>Resource Constraints:</strong> In environments with limited memory (like embedded systems or mobile devices), using too much memory can lead to performance degradation or crashes.</li>
										  <li><strong>Cost:</strong> Memory is a finite resource, and using it efficiently can reduce costs, especially in cloud computing where you pay for the resources you use.</li>
										</ul>
										</p>
										<p><strong>3.Classes of Problems and Orders of Growth</strong></p>
										
										<strong>Classes of Problems</strong>
										<ul>
										  <li><strong>Constant Time (O(1)):</strong> Execution time remains constant regardless of input size. Example: Accessing an element in an array by its index.</li>
										  <li><strong>Linear Time (O(n)):</strong> Execution time increases linearly with input size. Example: Searching for an element in an unsorted list.</li>
										  <li><strong>Logarithmic Time (O(log n)):</strong> Execution time increases logarithmically with input size. Example: Binary search in a sorted array.</li>
										  <li><strong>Linearithmic Time (O(n log n)):</strong> Execution time grows in proportion to n times the logarithm of n. Example: Merge sort and quicksort.</li>
										  <li><strong>Quadratic Time (O(n¬≤)):</strong> Execution time increases with the square of the input size. Example: Bubble sort or selection sort.</li>
										  <li><strong>Exponential Time (O(2‚Åø)):</strong> Execution time doubles with each additional element. Example: Solving the traveling salesman problem using brute force.</li>
										  <li><strong>Factorial Time (O(n!)):</strong> Execution time grows factorially with the input size. Example: Generating all permutations of a set.</li>
										</ul>
										
										<p><strong>Orders of Growth</strong><br>Growth rates help evaluate best, worst, and average-case performance, guiding algorithm selection for better efficiency in real-world applications.</p></p>
		

<p><strong>4.Takeaways from Different Design Principles from Chapter 2</strong></p>

<p>As I explored various algorithms, several key concepts emerged that significantly enhanced my understanding of algorithmic design:</p>

<ul>
  <li><strong>AVL Trees and Red-Black Trees:</strong> Emphasized the importance of maintaining balance in data structures, ensuring efficient operations like insertion, deletion, and searching, typically in O(log n) time. This is crucial for performance as datasets grow.</li>
  <li><strong>Depth-First Search (DFS) and Breadth-First Search (BFS):</strong> Illustrated how different strategies can effectively solve problems. DFS is more exploratory, diving deep into paths, while BFS systematically explores all neighbors at the current depth, making it ideal for finding the shortest path in unweighted graphs.</li>
  <li><strong>Sorting Algorithms (Merge Sort and Quick Sort):</strong> Provided insights into data organization. Merge Sort employs a divide-and-conquer approach, while Quick Sort strategically partitions elements around a pivot.</li>
</ul>

<p>Overall, these insights into balanced data structures, graph traversal methods, and sorting algorithms have given me a solid foundation in algorithmic principles and their practical applications, emphasizing the importance of efficiency and strategy in problem-solving.</p>


<p><strong>5.Hierarchical Data and Tree Data Structures</strong></p>

<p>Hierarchical data structures are essential for organizing data in a way that reflects relationships and hierarchies. Trees are a fundamental type of hierarchical data structure that consist of nodes connected by edges, with a single root node at the top and various levels of child nodes below. Different types of tree data structures are optimized for various problem scenarios, each offering unique advantages in terms of performance, efficiency, and usability.</p>

<ul>
  <li><strong>Tree:</strong> A collection of nodes connected by edges, where each node has a value and may have zero or more child nodes. <strong>Use Case:</strong> Representing hierarchical data like file systems, organizational structures, and XML/HTML documents.</li>
  <li><strong>Binary Search Tree (BST):</strong> A tree where each node has at most two children, with the left child containing values less than the parent node and the right child containing values greater than the parent. <strong>Use Case:</strong> Dynamic data retrieval, such as in databases.</li>
  <li><strong>AVL Tree:</strong> A self-balancing BST that maintains a balance factor for each node, ensuring that the heights of the two child subtrees differ by at most one. <strong>Use Case:</strong> Efficient scenarios with frequent insertions and deletions.</li>
  <li><strong>2-3 Tree:</strong> A balanced search tree where each node can have either two or three children, ensuring all leaves are at the same depth. <strong>Use Case:</strong> Databases and file systems requiring balanced search trees.</li>
  <li><strong>Red-Black Tree:</strong> A self-balancing BST with an additional color property (red or black) to maintain balance. <strong>Use Case:</strong> Widely used in associative arrays and sets.</li>
  <li><strong>Heap:</strong> A complete binary tree satisfying the heap property, where each parent node is either greater than (max-heap) or less than (min-heap) its child nodes. <strong>Use Case:</strong> Priority queues.</li>
  <li><strong>Trie:</strong> A specialized tree for storing strings, where each node represents a character of a string. <strong>Use Case:</strong> Autocomplete systems, spell checkers, and IP routing.</li>
</ul>


<p><strong>6.The Need for Array Query Algorithms</strong></p>

<p><strong>Why They Are Important:</strong></p>
<ul>
  <li><strong>Efficiency:</strong> Minimize retrieval and processing time as datasets grow.</li>
  <li><strong>Dynamic Data Handling:</strong> Enable frequent updates and queries on data.</li>
  <li><strong>Complex Operations:</strong> Simplify tasks like range queries or pattern matching.</li>
</ul>

<p><strong>Applications:</strong></p>
<ul>
  <li><strong>Database Management:</strong> Fast record retrieval and indexing.</li>
  <li><strong>Search Engines:</strong> Quickly return relevant search results.</li>
  <li><strong>Data Analysis:</strong> Filter and aggregate large datasets.</li>
  <li><strong>Computer Graphics:</strong> Render images and manage pixel data.</li>
  <li><strong>Machine Learning:</strong> Efficient data access during training and inference.</li>
</ul>

<p><strong>Principles:</strong></p>
<ul>
  <li><strong>Time Complexity:</strong> Optimize efficiency, e.g., O(1) for direct access or O(log n) for binary search.</li>
  <li><strong>Space Complexity:</strong> Minimize memory usage.</li>
  <li><strong>Data Structure Choice:</strong> Select appropriate structures like hash tables for fast lookups.</li>
  <li><strong>Preprocessing:</strong> Prepare data to enable faster queries, e.g., building indexes.</li>
  <li><strong>Trade-offs:</strong> Balance time and space complexity based on application needs.</li>
</ul>


<p><strong>7.Differentiating Between Trees and Graphs</strong></p>

<ul>
  <li><strong>Trees:</strong> Hierarchical data structures with nodes connected by edges, featuring a single root node and no cycles.</li>
  <ul>
    <li><strong>Properties:</strong> Acyclic, connected, hierarchical structure, single root node.</li>
    <li><strong>Traversals:</strong></li>
    <ul>
      <li><strong>Pre-order:</strong> Visit root, left subtree, then right subtree.</li>
      <li><strong>In-order:</strong> Visit left subtree, root, then right subtree.</li>
      <li><strong>Post-order:</strong> Visit left subtree, right subtree, then root.</li>
    </ul>
    <li><strong>Applications:</strong> Hierarchical data representation, binary search trees, expression trees in compilers.</li>
  </ul>
  <li><strong>Graphs:</strong> A collection of nodes connected by edges, which can be directed or undirected and may contain cycles.</li>
  <ul>
    <li><strong>Properties:</strong> Can be cyclic or acyclic, connected or disconnected, lacks hierarchical structure.</li>
    <li><strong>Applications:</strong> Network routing, social network analysis, recommendation systems.</li>
  </ul>
</ul>


<p><strong>8.Sorting and Searching Algorithms</strong></p>

<ul>
    <p><strong>Sorting and Searching Algorithms</strong><br>
        Sorting and searching algorithms are essential for organizing and retrieving data efficiently. Here‚Äôs a brief overview of common algorithms, their techniques, and real-world connections.</p>
        
        <p><strong>Sorting Algorithms</strong></p>
        
        <p><strong>Bubble Sort:</strong><br>
        <strong>Technique:</strong> Repeatedly compares and swaps adjacent elements until the list is sorted.<br>
        <strong>Real-World Connection:</strong> Like sorting playing cards by repeatedly comparing and swapping.</p>
        
        <p><strong>Selection Sort:</strong><br>
        <strong>Technique:</strong> Divides the list into sorted and unsorted regions, selecting the smallest element from the unsorted region.<br>
        <strong>Real-World Connection:</strong> Similar to selecting the best candidate from a pool of applicants.</p>
        
        <p><strong>Insertion Sort:</strong><br>
        <strong>Technique:</strong> Builds a sorted array by inserting each element into its correct position.<br>
        <strong>Real-World Connection:</strong> Like organizing a hand of playing cards by inserting each card into the right spot.</p>
        
        <p><strong>Merge Sort:</strong><br>
        <strong>Technique:</strong> A divide-and-conquer algorithm that splits the array, sorts each half, and merges them.<br>
        <strong>Real-World Connection:</strong> Comparable to organizing a library by sorting smaller sections before combining them.</p>
        
        <p><strong>Quick Sort:</strong><br>
        <strong>Technique:</strong> Selects a pivot and partitions elements into two sub-arrays, sorting them recursively.<br>
        <strong>Real-World Connection:</strong> Like organizing a bookshelf by using a reference book to arrange others.</p>
        
        <p><strong>Heap Sort:</strong><br>
        <strong>Technique:</strong> Utilizes a binary heap to sort elements by repeatedly extracting the maximum.<br>
        <strong>Real-World Connection:</strong> Similar to prioritizing tasks based on importance.</p>
        
        <p><strong>Searching Algorithms</strong></p>
        
        <p><strong>Linear Search:</strong><br>
        <strong>Technique:</strong> Iterates through each element until the target is found.<br>
        <strong>Real-World Connection:</strong> Like searching for a specific book by checking each one.</p>
        
        <p><strong>Binary Search:</strong><br>
        <strong>Technique:</strong> Requires a sorted array; divides the search interval in half.<br>
        <strong>Real-World Connection:</strong> Similar to looking up a word in a dictionary.</p>
        
        <p><strong>Hashing:</strong><br>
        <strong>Technique:</strong> Maps keys to locations in a hash table for quick lookups.<br>
        <strong>Real-World Connection:</strong> Like using a filing cabinet where files are quickly retrievable by label.</p>
  </ul>
</ul>


<p><strong>9.Importance of Graph Algorithms with Respect to Spanning Trees and Shortest Paths</strong><br>
    Graph algorithms are vital for addressing real-world problems, particularly in the contexts of spanning trees and shortest paths. Spanning trees, which connect all vertices in a graph without cycles, are essential for efficient network design, such as minimizing connections in telecommunications and infrastructure projects through Minimum Spanning Tree (MST) algorithms like Kruskal's and Prim's.</p>
    
    <p>On the other hand, shortest path algorithms, such as Dijkstra's and Bellman-Ford, are crucial for navigation and routing applications, enabling systems like GPS to find the quickest routes between locations. Overall, these algorithms play a significant role in optimizing connectivity and efficiency in various applications.</p>


    <p><strong>10. The different studied algorithm design techniques.</strong><br>
        Algorithm design techniques are systematic approaches used to develop efficient solutions for computational problems. One prominent technique is <strong>divide and conquer</strong>, which involves breaking a problem into smaller subproblems, solving each independently, and combining their solutions; examples include Merge Sort and Binary Search.</p>
        
        <p><strong>Dynamic programming</strong> is another important technique that optimizes problems by breaking them into overlapping subproblems and storing their results to avoid redundant calculations, as seen in the Fibonacci sequence and the Knapsack problem.</p>
        
        <p><strong>Greedy algorithms</strong> make a series of locally optimal choices in the hope of finding a global optimum, with applications in Minimum Spanning Trees and Huffman coding.</p>
        
        <p><strong>Backtracking</strong> explores all possible solutions and abandons those that fail to meet constraints, useful in puzzles like Sudoku and the N-Queens problem.</p>
        
        <p>Together, these techniques provide a robust framework for solving a wide range of computational challenges in computer science.</p>
										
										
										</p>

						</div>
					</div>
				</section>

			

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>
